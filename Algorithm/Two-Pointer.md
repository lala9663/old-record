## 투 포인터란?

배열 또는 리스트에서 두 개의 포인터를 사용하여 효율적으로 원하는 결과를 얻는 알고리즘이다.

중요한 점은 투포인터 알고리즘을 사용할 땐 꼭 정렬이 되어 있어야 한다.

이 알고리즘은 주로 선형 시간 복잡도에 해결할 수 있는 문제에 적용되며, 배열이나 리스트를 한 번 순회하면서 
원하는 조건을 만족하는 부분을 찾거나 원하는 값을 계산하는 데 사용된다.

이런 문제를 예시로 들어보자 

```
Q. 정렬된 리스트 A와 타겟 값 B가 주어졌을 때, 두 수의 합이 S가 되는 순서쌍을 모두 구하여라.
> A = [1, 3, 5, 6, 9, 11, 12, 16, 17, 19, 22, 25, 28]
> B = 27
```

### 반복문으로 풀면 

```
int[] A = {1, 3, 5, 6, 9, 11, 12, 16, 17, 19, 22, 25, 28};
int B = 27;
  for (int i = 0; i < A.length; i++) {
    for (int j = i + 1; j < A.length; j++) {
      if (A[i] + A[j] == B) {
        System.out.println(A[i] + A[j]);
      }
    }
  }
```

이런식으로 풀면 간단하게 풀 수 있다. 하지만 시간 복잡도는 O(n^2)가 된다.

### 이 문제를 투 포인터를 이용해 풀면
```
int[] A = {1, 3, 5, 6, 9, 11, 12, 16, 17, 19, 22, 25, 28};
int B = 27;

int left = 0; // 왼쪽 포인터 초기화
int right = A.length - 1; // 오른쪽 포인터 초기화

while (left < right) { // 왼쪽 포인터가 오른쪽 포인터보다 작은 동안 반복
    int sum = A[left] + A[right]; // 현재 왼쪽 포인터와 오른쪽 포인터가 가리키는 원소의 합 계산

    if (sum == B) { // 합이 목표값 B와 같다면
        System.out.println(A[left] + " + " + A[right] + " = " + B); // 결과 출력
        left++; // 왼쪽 포인터를 오른쪽으로 한 칸 이동
        right--; // 오른쪽 포인터를 왼쪽으로 한 칸 이동
    } else if (sum < B) { // 합이 목표값 B보다 작다면
        left++; // 왼쪽 포인터를 오른쪽으로 한 칸 이동하여 합을 증가시킴
    } else { // 합이 목표값 B보다 크다면
        right--; // 오른쪽 포인터를 왼쪽으로 한 칸 이동하여 합을 감소시킴
    }
}
```

### 시간복잡도 

해당 문제는 정렬되어 있는 상태이기 때문에 O(n) 지만, 정렬되어 있지 않으면 정렬 먼저 해야 하기 때문에 O(nlogn) 정도의 시간 복잡도로 문제를 풀 수 있다.


