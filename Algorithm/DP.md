## DP(Dynamic Programming)

다이나믹 프로그래밍(또는 동적 계획법)은 기본적인 아이디어로 **하나의 큰 문제를 여러개의 작은 문제로 나누어서 그 결과를 저장하여 다시 큰 문제를 해결할 때 사용**
하는 것으로 특정한 알고리즘이 아닌 하나의 문제해결 패러다임으로 볼 수 있다.  

## 피보나치 수열

동적 계획법의 대표적인 것이 피보나치 수열이다.  
피보나치 수열은 1항 2항은 1, 3항부터는 바로 앞의 두 항을 더한 수로 정의된다. 
```
(0), 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89...
```

프로그래밍에서 피보나치 수열은 보통 재귀를 통해 표현한다.
```
int fibo(int n)
  {
    if (n<=2)
      return 1;
    else
      return fibo(n-1) + fibo(n-2);
   }
```

![](https://velog.velcdn.com/images%2Fchelsea%2Fpost%2F627c053e-8a71-48e7-b0b2-7b8d327963a2%2F%E1%84%8C%E1%85%A2%E1%84%80%E1%85%B1%E1%84%91%E1%85%B5%E1%84%87%E1%85%A9.gif)

이런식으로 진행되면 이미 진행 했던 연산도 다시 연산을 해야해서 시간복잡도가 엄청나게 늘어난다.  

## 이걸 DP(동적 계획법)으로 

위의 예시처럼 이미 했던 연산이 반복되어 결점을 보완하기 위해서 동적 계획법이 고안되었다.  
처음 진행되는 연산은 기록해 두고, 이미 진행했던 연산이라면 다시 연산하는 것이 아니라 기록되어 있는 값을 가져온다.

```
int fiboData[100] = {0,};

int fibo(int n)
{
  if (n<=2) 
    return 1;
  if (fiboData[n]==0)
    fiboData[n] = fibo(n-1) + fibo(n-2);
  return fiboData[n];
}
```

이 처럼 배열을 만들어두고 내가 원하는 값을 꺼내는 방식이다.  

## 메모이제이션(Memoization)

이렇게 동일한 문제를 반복해야 할 경우, 한 번 계산된 결과를 저장해 두었다가 활용하는 방식으로 중복 계산을 줄이는 것을 **메모이제이션** 이라고 한다.  
